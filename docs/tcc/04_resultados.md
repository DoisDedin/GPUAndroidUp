4 Resultados e Discussão

4.1 Configuração dos benchmarks

A campanha de 30/11 percorreu 48 cenários por dispositivo (16 botões × três escalas), com os chips superiores fixados em 12 iterações por cenário e lotes de 12 pacotes para os modos “x10”. Os testes foram realizados em três aparelhos físicos representando perfis distintos de hardware: Galaxy S21 (Exynos 2100), Moto G04s (Spreadtrum T606) e Moto G84 5G (Snapdragon 695). Cada cenário contemplou duas cargas principais — 4 096 e 16 384 pontos por sensor — mantendo 10 sensores simultâneos para FFT. As execuções single processam um único pacote por iteração, enquanto as variantes x10 reaproveitam os mesmos parâmetros para 12 pacotes consecutivos, preservando determinismo no gerador de dados e permitindo avaliar amortização de transferência. Cada combinação foi repetida doze vezes antes de calcular média, desvio e limites mínimos/máximos, o que garante amostras consistentes para comparar delegates. Todos os resultados foram consolidados em arquivos CSV e em gráficos produzidos a partir dos benchmarks, que evidenciam a inclinação linear do baseline em CPU e o platô dos delegates TFLite, exatamente como prevê o enquadramento de granularidade descrito na Seção 2.7.

4.2 Resultados de MAD

4.2.1 Galaxy S21

No Galaxy S21, o MAD com 4 096 pontos (single) levou 2,70 ms na CPU Kotlin, enquanto os delegates TFLite CPU e GPU ficaram em torno de 0,63 ms (speedup ≈4,3×) e o NNAPI permaneceu próximo da CPU com 2,53 ms. Ao processar 12 pacotes consecutivos, o tempo médio caiu de 25,5 ms (CPU) para 7,55 ms (TFLite CPU) e 7,61 ms (GPU), ao passo que o NNAPI oscilou em 45,2 ms por repetição devido ao custo de coordenação com o driver. Na escala de 16 384 pontos o contraste aumenta: a CPU Kotlin consumiu 24,6 ms por pacote single e 271,8 ms por repetição x10, enquanto o delegate GPU manteve 2,56 ms e 32,5 ms, respectivamente, resultando em ganhos de até 9,6×; o delegate CPU ficou em 12,3 ms/32,9 ms e o NNAPI em 5,68 ms/69,4 ms. Esses números mostram que o S21 se beneficia mais de delegados GPU/CPU quando o tamanho do vetor cresce, validando a importância de granularidade grossa descrita na Seção 2.7. Como consequência, os delegates reduzem o tempo ativo de CPU e favorecem menores picos de potência, especialmente nos modos x10 em que a amortização do buffer reduz o custo por pacote.

4.2.2 Moto G04s

No Moto G04s, o MAD expôs um descompasso ainda maior entre CPU e delegates. Com 4 096 pontos single, a CPU levou 121,5 ms, ao passo que os delegates CPU/GPU ficaram ao redor de 60 ms (≈2× mais rápidos) e o NNAPI em 62,4 ms. O cenário x10 a 4 096 pontos destacou a GPU: 192,4 ms na CPU contra apenas 28,3 ms na GPU (speedup ≈6,8×), enquanto o delegate CPU permaneceu em 120 ms e o NNAPI ultrapassou 226 ms. Em 16 384 pontos single, o CPU Kotlin precisou de 85,7 ms, contrastando com 8,22 ms no delegate GPU e 8,39 ms no TFLite CPU (≈10×) e 29,7 ms no NNAPI. Com 12 pacotes de 16 384 pontos, a CPU subiu para 931,5 ms e os delegates CPU/GPU ficaram perto de 103 ms, mantendo mais de 9× de vantagem; o NNAPI caiu para 405 ms, mas ainda distante dos demais. O perfil do G04s evidencia que delegar para GPU é determinante para atingir latências sub-30 ms em cargas grandes e que o custo de transferência domina quase todo o tempo observado nos delegates CPU, confirmando a necessidade de granularidade grossa discutida na Seção 2.7 para amortizar overheads e reduzir consumo energético.

4.2.3 Moto G84 5G

O Moto G84 apresentou resultados homogêneos entre os delegates TFLite. Em 4 096 pontos single, a CPU Kotlin consumiu 4,12 ms e todos os delegates ficaram próximos de 1,0 ms (≈4× mais rápidos). No modo x10, a CPU registrou 49,1 ms e os delegates 11,9 ms. Na escala de 16 384 pontos, as execuções single caíram de 35,7 ms (CPU) para ~3,8 ms (TFLite CPU/GPU/NNAPI) e, em x10, de 440,8 ms para 45,1 ms. Como os três delegates compartilham o mesmo gargalo de transferência, as diferenças ficam abaixo de 2% e o ganho sobre a CPU deriva principalmente da redução do tempo de computação. Isso sugere que o Moto G84 5G já equilibra CPU e GPU integradas, beneficiando-se de qualquer delegate TFLite para poupar ciclos e reduzir o tempo ativo em frequências elevadas, cenário que corresponde a uma granularidade intermediária conforme o modelo conceitual da Seção 2.7.

4.3 Resultados de FFT

Assim como evidenciado pelos gráficos de tempo e speedup e pela discussão de granularidade da Seção 2.7, entre 70 % e 85 % do tempo dos delegates FFT é gasto transferindo buffers, o que aproxima os tempos das versões CPU/GPU/NNAPI e limita os ganhos quando não há batching ou quando o grafo mantém granularidade fina. Ainda assim, o comportamento varia conforme a capacidade de CPU de cada dispositivo.

4.3.1 Galaxy S21

Em 4 096 pontos single, a FFT em CPU Kotlin levou 4,09 ms contra 2,46 ms nos delegados TFLite (speedup ≈1,66×). Quando se processam 12 pacotes, a CPU subiu para 33,2 ms e os delegates variaram entre 31,4 ms (TFLite CPU) e 32,4 ms (GPU), já que ~78 % do tempo continua em transferência. Em 16 384 pontos single, o CPU Kotlin alcançou 13,3 ms e os delegates ficaram na faixa de 10,9–11,1 ms, com ganhos de cerca de 20 %; a versão x10 registrou 146 ms na CPU e ~132 ms em qualquer delegate. O S21 mostra que o gargalo de I/O neutraliza a vantagem de GPU/NNAPI, exigindo granularidade mais grossa para observar benefícios significativos e reforçando a importância de otimizações que minimizem cópias.

4.3.2 Moto G04s

No Moto G04s, o limite imposto pelo CPU quad-core torna o ganho com GPU marcante. Para 4 096 pontos single, a CPU levou 83 ms, a GPU 8,28 ms (speedup ≈10×), o TFLite CPU 12,98 ms e o NNAPI 13,58 ms. Em x10, a CPU subiu para 230,8 ms, ao passo que GPU e TFLite CPU permaneceram abaixo de 99 ms. Em 16 384 pontos single, a CPU caiu para 51,5 ms por conta da escala, mas ainda ficou acima dos 33–35 ms observados nos delegates; com lotes de 12 pacotes o CPU alcançou 606,8 ms e os delegates ficaram em 383 ms. Embora a transferência represente quase 75 % do tempo dos delegates, o G04s ainda colhe speedups expressivos no GPU por aliviar o núcleo ARM limitado, confirmando a tendência descrita na Seção 2.7: granularidade grossa é determinante para desbloquear ganhos em hardware de entrada.

4.3.3 Moto G84 5G

No Moto G84 5G, os três delegates TFLite ficaram praticamente empatados em todas as escalas porque a transferência consome cerca de 70 % do tempo. Em 4 096 pontos single, a CPU ficou em 7,95 ms contra 3,9 ms nos delegates (≈2×). Em x10, a CPU subiu para 86,3 ms e os delegates para 46,7 ms. Em 16 384 pontos single, o CPU Kotlin alcançou 46,4 ms e os delegates permaneceram entre 16,5 e 16,7 ms, atingindo speedup próximo de 2,8×; no modo x10, 644 ms versus ~197 ms. Esses resultados reforçam que, em um intermediário moderno, qualquer delegate TFLite já entrega ganhos estáveis, mas o limite de transferência impede saltos maiores sem reescrever o pipeline de buffers ou alterar a granularidade do grafo conforme discutido na Seção 2.7.

4.4 Resultados energéticos

O teste energético automatizado executou os quatro cenários MAD (CPU Kotlin, TFLite CPU, TFLite GPU e TFLite NNAPI) em blocos de 100 execuções cada, registrando queda de bateria, energia acumulada em nWh, variação de temperatura e modo de economia antes/depois de cada bloco. Os registros estruturados alimentam a classificação qualitativa presente nas tabelas de benchmark: o ramo CPU Kotlin é marcado como “Alta”, o TFLite CPU como “Média”, o TFLite GPU como “Baixa” e o NNAPI como “Baixa/Média”. Essa diferença de ordem de grandeza confirma o esperado: ao processar a mesma carga de trabalho em menos tempo e com menor atividade de CPU, os delegates drenaram apenas uma fração da energia consumida pelo baseline Kotlin. As leituras de temperatura também permaneceram mais estáveis nos delegates, indicando menor estresse térmico durante execuções prolongadas. Tais efeitos reforçam que granularidade grossa, ao amortizar o custo fixo de transferência, contribui diretamente para reduzir o tempo ativo dos componentes e, por consequência, o consumo energético.

4.5 Discussão geral

Os resultados demonstram forte dependência do hardware-alvo. O Moto G04s, limitado por CPU, é o que mais se beneficia de delegar para GPU ou mesmo para o backend TFLite CPU, alcançando speedups superiores a 10× em MAD e FFT. O Galaxy S21 e o Moto G84 5G apresentam CPUs mais capazes e, por consequência, ganhos moderados em FFT quando a transferência domina, embora continuem colhendo ganhos substanciais em MAD (especialmente na escala 4×). Em todos os dispositivos, o batching de 12 pacotes reduz o tempo efetivo por pacote e melhora o throughput, mas deixa claro que 70–90 % do tempo dos delegates corresponde a copiar dados, como evidenciado nos gráficos de tempo e pela análise de granularidade da Seção 2.7. Assim, futuras otimizações devem priorizar buffers persistentes e pipelines de aquisição in-place para liberar os delegates de transferências redundantes e desbloquear ganhos adicionais de desempenho e eficiência energética.
